// ==========================================
// Part 1: 主程式 (從 Address 0 開始)
// ==========================================

// 初始化
ADI $r0, $r0, 0     // R0 = 0
ADI $r1, $r0, 0     // R1 = 0 (計數器)
ADI $r2, $r0, 0     // R2 = 0 (中斷標記，平時是 0)
ADI $r3, $r0, 100   // R3 = 100 (這是我們的資料存檔區 Data Address)

// 無窮迴圈 (Main Loop)
LOOP:
    ADI $r1, $r1, 1     // R1 = R1 + 1 (努力工作中...)
    JMP LOOP            // 回去繼續數


// ==========================================
// Part 2: 中斷服務程式 (ISR)
// ★ 必須放在 Address 250 (0xFA) ★
// ==========================================
// (請確保這段 code 在 hex 檔的第 250 行位置)

ISR_START:
    // 1. 保存現場 (Context Save)
    // 把主程式正在用的 R1 存到記憶體 [100]
    // 語法: SWD $src, $base, offset
    SWD $r1, $r3, 0     // Mem[100] = R1

    // 2. 執行中斷任務
    // 我們把 R2 改成 88，這樣你看波形就知道「中斷發生了！」
    ADI $r2, $r0, 88    // R2 = 88

    // 3. 恢復現場 (Context Restore)
    // 雖然這裡 R1 沒被改壞，但正規 OS 都要做這步
    // 從記憶體 [100] 讀回 R1
    // 語法: LWD $dest, $base, offset
    LWD $r1, $r3, 0     // R1 = Mem[100]

    // 4. 返回主程式
    IRET                // PC = EPC (回到 LOOP 裡面的某一行)